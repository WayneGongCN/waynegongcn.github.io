<!doctype html>
<html lang="en">
  <head>
  <!-- Meta -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  


  
    
    
<link rel="stylesheet" href="/css/github.css">

  

  <meta name="title" content="尾调用优化 | 风灯零乱 | 一个程序员的个人博客">
  <meta name="keywords" content="博客,独立开发,技术沉淀,思考总结,Web 前端">

  <!-- OpenGraph -->
  <meta name="description" content="当函数的调用层数非常多时，需要同时保存成千上百个调用记录，调用栈会消耗不少内存，甚容易导致栈溢出。 尾调用的调用栈则特别易于优化，从而可减少内存空间的使用，也能提高运行速度。 尾调用尾调用 (tail call) 指的是一个函数的最后一条语句是一个返回调用函数的语句。 &#x2F;&#x2F; 属于尾调用 function bar(data) &amp;#123;   if ( a(data) ) &amp;#123;     re">
<meta property="og:type" content="article">
<meta property="og:title" content="尾调用优化">
<meta property="og:url" content="https://waynegong.cn/posts/10156.html">
<meta property="og:site_name" content="风灯零乱">
<meta property="og:description" content="当函数的调用层数非常多时，需要同时保存成千上百个调用记录，调用栈会消耗不少内存，甚容易导致栈溢出。 尾调用的调用栈则特别易于优化，从而可减少内存空间的使用，也能提高运行速度。 尾调用尾调用 (tail call) 指的是一个函数的最后一条语句是一个返回调用函数的语句。 &#x2F;&#x2F; 属于尾调用 function bar(data) &amp;#123;   if ( a(data) ) &amp;#123;     re">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-10-10T16:00:00.000Z">
<meta property="article:modified_time" content="2022-02-09T15:59:20.067Z">
<meta property="article:author" content="waynegong">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="独立开发">
<meta property="article:tag" content="技术沉淀">
<meta property="article:tag" content="思考总结">
<meta property="article:tag" content="Web 前端">
<meta name="twitter:card" content="summary">

  <!-- Title -->
  <title>尾调用优化 | 风灯零乱 | 一个程序员的个人博客</title>

  <!-- 收录验证 -->
  <meta name="sogou_site_verification" content="Ya613VDsLE" />
  <meta name="360-site-verification" content="cede68bb0b1448f4d5dcc6cdbdb1239d" />
  <meta name="baidu-site-verification" content="code-CXJVSO2lgq" />

  <!-- GTM -->
  
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-K9CJL9P');</script>
  

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/lib/bootstrap-5.1.3/css/bootstrap.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>

  <body class="container col-lg-8 col-md-10 justify-content-center">
    <header class="container-fluid">
  <nav class="row align-items-center justify-content-between mb-2" style="border-bottom: 2px solid;">
    <a class="col navbar-brand text-dark" href="/">风灯零乱</a>

    <ul class="col-auto row p-0 m-0">
      
        
        <li class="col-auto none-list-style">
          <a class="text-dark text-decoration-none" href="/archives/">
            归档
          </a>
        </li>
      
        
        <li class="col-auto none-list-style">
          <a class="text-dark text-decoration-none" href="/categories/">
            分类
          </a>
        </li>
      
        
        <li class="col-auto none-list-style">
          <a class="text-dark text-decoration-none" href="/tags/">
            标签
          </a>
        </li>
      
    </ul>
  </nav>
</header>


    <section class="container-fluid">
  <div class="pb-3 pt-2">
    <h1>
      尾调用优化
    </h1>
    <time class="link-secondary fw-light">2018-10-11</time>
  </div>

  <main class="markdown-body">
    <p>当函数的调用层数非常多时，需要同时保存成千上百个调用记录，调用栈会消耗不少内存，甚容易导致<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%88%E6%BA%A2%E5%87%BA">栈溢出</a>。</p>
<p>尾调用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A">调用栈</a>则特别易于优化，从而可减少内存空间的使用，也能提高运行速度。</p>
<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用 (tail call) 指的是<strong>一个函数的最后一条语句是一个返回调用函数的语句</strong>。</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// 属于尾调用</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">data</span>) </span>&#123;
  <span class="hljs-keyword">if</span> ( a(data) ) &#123;
    <span class="hljs-keyword">return</span> b(data);
  &#125;
  <span class="hljs-keyword">return</span> c(data);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">data</span>) </span>&#123;
  a(data);
  <span class="hljs-keyword">return</span> b(data);
&#125;</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// 不属于尾调用</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo1</span>(<span class="hljs-params">data</span>) </span>&#123;
  <span class="hljs-keyword">return</span> a(data) + <span class="hljs-number">1</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params">data</span>) </span>&#123;
  <span class="hljs-keyword">var</span> ret = a(data);
  <span class="hljs-keyword">return</span> ret;
&#125;</code></pre>

<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>当一个函数被调用时，函数的调用位置与返回位置被保存在调用栈中，调用结束时才能带着返回值回到该位置。</p>
<p>在尾调用这种特殊情形中，计算机理论上可以不需要记住尾调用的位置而从被调用的函数直接带着返回值返回调用函数的返回位置。</p>
<p>尾调用消除即是在不改变当前调用栈（也不添加新的返回位置）的情况下跳到新函数的一种优化。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>在尾调用的情况下调用自身的特殊尾调用称为尾递归。</p>
<h3 id="优化尾递归的分析"><a href="#优化尾递归的分析" class="headerlink" title="优化尾递归的分析"></a>优化尾递归的分析</h3><p>由于函数自身调用次数很多，递归层级很深，尾递归优化则使原本 <code>O(n)</code> 的调用栈空间只需要 <code>O(1)</code>。</p>
<p>“尾调用优化” 对递归操作意义重大，ES6 中明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。</p>
<p>所以在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<p>现有recsum函数如下：</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recsum</span> (<span class="hljs-params">num</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> num + recsum(num - <span class="hljs-number">1</span>)
&#125;</code></pre>

<p>调用recsum(5)为例:</p>
<pre><code class="hljs plaintext">recsum(5)
5 + recsum(4)
5 + (4 + recsum(3))
5 + (4 + (3 + recsum(2)))
5 + (4 + (3 + (2 + recsum(1))))
5 + (4 + (3 + (2 + 1)))
5 + (4 + (3 + 3))
5 + (4 + 6)
5 + 10
15</code></pre>

<p>堆栈从左到右，增加到一个峰值后再计算从右到左缩小。</p>
<p>修改以上代码，可以成为尾递归：</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tailrecsum</span> (<span class="hljs-params">num, running_total=<span class="hljs-number">0</span></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> running_total
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tailrecsum(num - <span class="hljs-number">1</span>, running_total + num)
&#125;</code></pre>

<p>后者尾递归对内存的消耗</p>
<pre><code class="hljs plaintext">tailrecsum(5, 0) 
tailrecsum(4, 5) 
tailrecsum(3, 9)
tailrecsum(2, 12) 
tailrecsum(1, 14) 
tailrecsum(0, 15) 
15</code></pre>

<h3 id="递归函数的修改"><a href="#递归函数的修改" class="headerlink" title="递归函数的修改"></a>递归函数的修改</h3><p>由于要实现尾调用优化，函数的调用栈不在增加所以无法保持函数的局部变量，需要将局部变量以参数的形式传入，如上面的例子，来实现尾调用的优化。</p>
<p>递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。</p>
<p>对于其他支持”尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>

  </main>
</sectione>

    
<script src="/lib/bootstrap-5.1.3/js/bootstrap.bundle.min.js"></script>


  </body>
</html>