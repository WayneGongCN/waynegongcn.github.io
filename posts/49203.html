<!doctype html>
<html lang="en">
  <head>
      <!-- Meta -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- SEO Meta -->
  
  
  
  

  
    
    
<link rel="stylesheet" href="/lib/hljs/github.css">

  

  <meta name="title" content="JS CSS 如何阻塞页面渲染 | 风灯零乱 | 一个程序员的个人博客">
  <meta name="keywords" content="博客,独立开发,技术沉淀,思考总结,Web 前端">

  <!-- Title -->
  <title>JS CSS 如何阻塞页面渲染 | 风灯零乱 | 一个程序员的个人博客</title>

  <!-- OpenGraph -->
  <meta name="description" content="TLDR: CSS 和 JS 都会阻塞页面的 关键渲染路径 ，不同情况下阻塞效果不同：  内联 JS 的执行会阻塞 DOM 构建（Layout）； 外部 JS 的加载和执行都会阻塞 DOM 构建； 内联 CSS 的 CSSOM 构建会阻塞渲染树的构建，从而阻塞布局（Layout）； 外部 CSS 的加载和 CSSOM 构建都会阻塞渲染树的构建，从而阻塞布局； 在页面存在 CSS 和 JS 的情况下">
<meta property="og:type" content="article">
<meta property="og:title" content="JS CSS 如何阻塞页面渲染">
<meta property="og:url" content="https://waynegong.cn/posts/49203.html">
<meta property="og:site_name" content="风灯零乱">
<meta property="og:description" content="TLDR: CSS 和 JS 都会阻塞页面的 关键渲染路径 ，不同情况下阻塞效果不同：  内联 JS 的执行会阻塞 DOM 构建（Layout）； 外部 JS 的加载和执行都会阻塞 DOM 构建； 内联 CSS 的 CSSOM 构建会阻塞渲染树的构建，从而阻塞布局（Layout）； 外部 CSS 的加载和 CSSOM 构建都会阻塞渲染树的构建，从而阻塞布局； 在页面存在 CSS 和 JS 的情况下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_13-52-15.png">
<meta property="og:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_13-58-45.png">
<meta property="og:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_16-59-52.png">
<meta property="og:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_17-33-12.png">
<meta property="og:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_17-39-17.png">
<meta property="og:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_19-01-54.png">
<meta property="og:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_19-56-04.png">
<meta property="article:published_time" content="2020-10-24T16:00:00.000Z">
<meta property="article:modified_time" content="2022-02-11T15:24:49.899Z">
<meta property="article:author" content="Wayne Gong">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="独立开发">
<meta property="article:tag" content="技术沉淀">
<meta property="article:tag" content="思考总结">
<meta property="article:tag" content="Web 前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://waynegong.cn/images/2020/11/Snipaste_2020-11-03_13-52-15.png">

  <!-- 收录验证 -->
  <meta name="sogou_site_verification" content="Ya613VDsLE" />
  <meta name="360-site-verification" content="cede68bb0b1448f4d5dcc6cdbdb1239d" />
  <meta name="baidu-site-verification" content="code-CXJVSO2lgq" />

  <!-- GTM -->
  
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-K9CJL9P');</script>
  

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/lib/bootstrap-5.1.3/css/bootstrap-reboot.min.css">

  
<link rel="stylesheet" href="/lib/bootstrap-5.1.3/css/bootstrap.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  <meta name="generator" content="Hexo 6.0.0"></head>

  <body class="container d-flex flex-column  col-lg-8 col-md-10">
    <header class="container flex-grow-0 line-bottom mb-2 ">
      <nav class="row align-items-center justify-content-between">
  <a class="col navbar-brand text-dark" href="/">风灯零乱</a>

  <ul class="col-auto row p-0 m-0">
    
      
      <li class="col-auto list-style-none">
        <a class="text-dark text-decoration-none" href="/archives/">
          归档
        </a>
      </li>
    
  </ul>
</nav>

    </header>

    <section class="main d-flex flex-column flex-grow-1">
      <section class="container flex-grow-1">
  <div class="pb-3 pt-2">
    <h1>
      JS CSS 如何阻塞页面渲染
    </h1>
    <time class="link-secondary fw-light">2020-10-25</time>
  </div>

  <main class="markdown-body">
    <p>TLDR:</p>
<p>CSS 和 JS 都会阻塞页面的 关键渲染路径 ，不同情况下阻塞效果不同：</p>
<ul>
<li>内联 JS 的执行会阻塞 DOM 构建（Layout）；</li>
<li>外部 JS 的加载和执行都会阻塞 DOM 构建；</li>
<li>内联 CSS 的 CSSOM 构建会阻塞渲染树的构建，从而阻塞布局（Layout）；</li>
<li>外部 CSS 的加载和 CSSOM 构建都会阻塞渲染树的构建，从而阻塞布局；</li>
<li>在页面存在 CSS 和 JS 的情况下，CSSOM 的构建会阻塞他后面 JS 的执行；</li>
<li><code>script</code> 标签的 <code>async</code> 和 <code>derfer</code> 属性能使 JS 的加载不阻塞 DOM 构建；</li>
</ul>
<h2 id="测试-Demo"><a href="#测试-Demo" class="headerlink" title="测试 Demo"></a>测试 Demo</h2><p>为了验证关键渲染路径是如何被阻塞，可以运行一个 Web Server，并通过浏览器调试工具（Chrome DevTools – Performance）观察页面渲染过程。</p>
<p>一个简单的 <a href="https://github.com/zowiegong/critical-rendering-path" target="_blank" rel="noopener external nofollow noreferrer">Demo</a></p>
<h2 id="JS-如何阻塞页面渲染"><a href="#JS-如何阻塞页面渲染" class="headerlink" title="JS 如何阻塞页面渲染"></a>JS 如何阻塞页面渲染</h2><p>由于 JS 可能会修改 DOM，所以运行 JS 和构建 DOM 不能同时进行，所以 JS 会对页面渲染造成较大的影响。</p>
<p>验证 Js 对页面渲染的影响主要分为三种情况：</p>
<ol>
<li>内联方式的 JS</li>
<li>外部链接引入的 JS</li>
<li>外部链接并使用 async、defer 属性的 JS</li>
</ol>
<h3 id="内联-JS-对页面渲染的影响"><a href="#内联-JS-对页面渲染的影响" class="headerlink" title="内联 JS 对页面渲染的影响"></a>内联 JS 对页面渲染的影响</h3><p>修改 Demo 代码 <code>demo/static/index.html</code>:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span>
<span class="javascript">    <span class="hljs-keyword">const</span> stopTime = <span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">20</span></span>
<span class="javascript">    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() &lt; stopTime);</span>
<span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>得到如下结果：<br><img src="/images/2020/11/Snipaste_2020-11-03_13-52-15.png"></p>
<p>浏览器接收到 HTML 内容便立即开始 Parse HTML（构建 DOM） ，点击 Parse HTML 可以看到详细的执行耗时。如下：</p>
<p><img src="/images/2020/11/Snipaste_2020-11-03_13-58-45.png"></p>
<p>Parse HTML（构建 DOM）只需要 0.3ms，而 JS 却阻塞了 19.9ms，整个 Parse HTML 过程花费了约 20.1 ms。</p>
<p>假设 JS 代码执行需要更久的时间，则 Parse HTML 也会被拉长更久，无法进入下一步（Layout）。</p>
<p>可以得出结论，内联 JS 的执行会阻塞关键渲染路径。</p>
<h2 id="外链-JS-对页面渲染的影响"><a href="#外链-JS-对页面渲染的影响" class="headerlink" title="外链 JS 对页面渲染的影响"></a>外链 JS 对页面渲染的影响</h2><p>修改 Demo 代码 <code>demo/static/index.html</code>:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/block.js?t=100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<p>得到如下结果：</p>
<p><img src="/images/2020/11/Snipaste_2020-11-03_16-59-52.png"></p>
<p>与内联 JS 不同的是 Parse HTML 被分为两次了。</p>
<p>在首次 Parse HTML 中，浏览器解析了 <code>index.html</code> 中 <code>script</code> 标签之前的内容（0 – 3 行）并立即发起请求获取 <code>block.js</code>，停止了解析。</p>
<p>在等待 <code>block.js</code> 加载的过程中，浏览器没有对 <code>script</code> 标签后面的内容进行解析，而是对已经完成解析的这部分内容进行了布局和绘制（Paint）。<br>首次绘制（FP）的时间早于 <code>block.js</code> 加载完成的时间，但此时页面上仅显示 hello，内容不完整。</p>
<p><code>block.js</code> 加载完成后，浏览器没有对后面的 HTML 解析，而是先执行了 JS 代码。<br>直到代码执行完成后才开始对剩余内容解析、回流、重绘。</p>
<p>在等待外部 JS 加载完成的过程中，浏览器无法对 <code>script</code> 标签后面的内容进行解析，即 JS 的加载会阻塞 DOM 构建。<br>外部 JS 加载完成后需要先执行 JS，即 JS 的执行也会阻塞 DOM 构建。</p>
<p>可以得出结论，<strong>外链形式引入 JS 的加载、执行都会阻塞关键渲染路径</strong>。</p>
<h3 id="async、derfer-属性对页面渲染的影响"><a href="#async、derfer-属性对页面渲染的影响" class="headerlink" title="async、derfer 属性对页面渲染的影响"></a>async、derfer 属性对页面渲染的影响</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener external nofollow noreferrer">MDN 对这两个属性的解释</a>：</p>
<blockquote>
<p>async: 对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，并尽快解析和执行。</p>
</blockquote>
<blockquote>
<p>defer: 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。有 defer 属性的脚本会阻止 DOMContentLoaded 事件，直到脚本被加载并且解析完成。</p>
</blockquote>
<p>修改 Demo 代码 <code>demo/static/index.html</code>：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/block.js?t=100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<p>使用 async 属性时如下：</p>
<p><img src="/images/2020/11/Snipaste_2020-11-03_17-33-12.png"></p>
<p>使用 defer 属性时如下：</p>
<p><img src="/images/2020/11/Snipaste_2020-11-03_17-39-17.png"></p>
<p>可以发现，加上 <code>async</code>、<code>defer</code> 这两个属性后，<code>block.js</code> 的加载都没有影响到 Parse HTML。</p>
<p>浏览器接收到 HTML 后立即开始了页面的解析，当遇到了 script 标签便立即发起了请求去加载 <code>block.js</code>。</p>
<p>与之前不同的是，浏览器继续对 script 后面的内容进行了解析、布局、绘制。</p>
<p>可以得出结论，<code>async</code>、<code>defer</code> 属性都可以使外链引入的 JS 不阻塞 Parse HTML（DOM 构建）。</p>
<h2 id="CSS-资源如何阻塞页面渲染"><a href="#CSS-资源如何阻塞页面渲染" class="headerlink" title="CSS 资源如何阻塞页面渲染"></a>CSS 资源如何阻塞页面渲染</h2><p>不同于 JS，CSS 不会修改 DOM 所以不会阻塞构建 DOM，所以构建 DOM 与构建 CSSOM 井水不犯河水。</p>
<p>内联的 CSS 已经在 HTML 中一同返回，所有不会对 DOM 构建产生影响。</p>
<p>模拟外链 CSS 阻塞页面渲染，修改测试 Demo <code>demo/static/index.html</code>：</p>
<p>得到如下结果:</p>
<p><img src="/images/2020/11/Snipaste_2020-11-03_19-01-54.png"></p>
<p>浏览器需要将 DOM 和 CSSOM 合并成一颗渲染树（Render tree）后才能进行布局和绘制。</p>
<p>如果 CSS 通过外链引入，即使 CSS 不阻塞 DOM 构建，但在 CSS 加载完成之前都无法进行 CSSOM 构建也就无法进行渲染树的构建，从而导致阻塞关键渲染流程。</p>
<p>可以看到在 Parse HTML 完成后一直在等待 <code>block.css</code> 加载，直到 <code>block.css</code> 加载完成才进行 CSSOM 树的构建、渲染、绘制。</p>
<p>证明 CSS 会导致关键渲染路径阻塞。</p>
<h2 id="当-JS-遇见-CSS"><a href="#当-JS-遇见-CSS" class="headerlink" title="当 JS 遇见 CSS"></a>当 JS 遇见 CSS</h2><p>上述情况只讨论了 HTML + JS、HTML + CSS 的情况，如果 HTML、JS、CSS 都同时存在，对页面渲染又会有什么影响？</p>
<p>JS 之所以会阻塞 DOM 构建是因为 JS 可能会修改 DOM，所以只能按照顺序执行。</p>
<p>同理，JS 也有可能会修改样式，所以在 CSSOM 构建完成之前，JS 无法执行，也就是 CSSOM 会阻塞 JS 执行（JS 的位置在 CSS 之后的情况下）。</p>
<p>从头到位捋一遍他们之间的关系：<strong>CSS 会阻塞渲染树的构建和他后面的 JS 执行，JS 的执行和 DOM 构建又是相互阻塞的</strong>。</p>
<p>修改测试 Demo <code>demo/static/index.html</code>：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/block.js?t=100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/block.css?t=300&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/block.js?t=200&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>得到如下结果：</p>
<p><img src="/images/2020/11/Snipaste_2020-11-03_19-56-04.png"></p>
<p>可以发现，即使 <code>block.js?t=200</code> 比 <code>block.css?t=300</code> 先加载完成，但他并没有立即执行，而是等待 <code>block.css?t=300</code> 加载完成后才执行。</p>
<h2 id="CSS-为什么需要在页面头部"><a href="#CSS-为什么需要在页面头部" class="headerlink" title="CSS 为什么需要在页面头部"></a>CSS 为什么需要在页面头部</h2><p>CSS 不会阻塞 DOM 构建，但却会阻塞渲染树构建，从而阻塞布局影响关键渲染流程。</p>
<p>如果将 CSS 放在页面中间或者底部，CSS 不会阻塞 DOM 构建，已经解析完成的内容会被渲染出来。</p>
<p>这时一旦 CSS 加载完成页面则会重新渲染，可能造成页面变化。一方面不必要的重新渲染造成额外的性能负担，另一方面页面的变化体验也非常不好。</p>
<p>所以将重要的 CSS 资源放在页面头部，尽早开始加载，减少网络请求上阻塞的时间，避免页面阻塞提高渲染效率。</p>
<p>另外对于体积较大的 CSS 资源建议以外部链接的方式加载，这样则能充分利用缓存减少请求时间。</p>
<h2 id="JS-为什么需要在页面底部"><a href="#JS-为什么需要在页面底部" class="headerlink" title="JS 为什么需要在页面底部"></a>JS 为什么需要在页面底部</h2><p><code>script</code> 标签在不设置 <code>async</code>、<code>defer</code> 属性的情况下，会阻塞 DOM 构建。</p>
<p>如果将这样的 <code>script</code> 标签放在页面头部，在没有加载完成的情况下不会解析 <code>script</code> 后面的 HTML 内容，直到 JS 加载执行完成页面都会一直显示空白，体验非常不好。</p>
<p>将 JS 放在页面底部则不会有这样的问题，即使浏览器解析 HTML 在底部被阻塞了 script 标签之前的内容依然可以显示，用户依然能在第一时间看到完整的页面。</p>
<p>不过在有了 <code>async</code>、<code>derfer</code> 属性之后，<code>script</code> 标签的位置已经不是那么重要了。</p>
<p>现代的浏览器对页面解析和渲染也做了大量的工作，预加载扫描器等优化技术也极大的提升了渲染效率。</p>

  </main>
</sectione>
    </section>

    <footer class="container flex-grow-0 line-top mt-4 p-1 pb-2">
      <ul class="row align-items-center m-0 p-0 em-6 text-muted " >
  
  <li class="list-style-none p-0">© 2022 <a href="mailto:wayne.gong.cn@hotmail.com" class="text-reset">Wayne Gong</a> All Rights Reserved</li>

  <li class="list-style-none p-0">Powered by <a href="https://hexo.io/" class="text-reset" target="_blank" rel="noopener">Hexo</a></li>
  <li class="list-style-none p-0">Theme by <a href="https://github.com/WayneGongCN/hexo-theme-atheme" class="text-reset" target="_blank" rel="noopener">atheme</a></li>

  
    
    <li class="list-style-none p-0"><a href="https://github.com/waynegongcn/waynegongcn.github.io/edit/master/source/_posts/JS CSS 如何阻塞页面渲染.md" class="text-reset" target="_blank" rel="noopener">Edit Page</a></li>
  
</ul>


    </footer>

    <!-- 
<script src="/lib/bootstrap-5.1.3/js/bootstrap.bundle.min.js"></script>
 -->
  </body>
</html>