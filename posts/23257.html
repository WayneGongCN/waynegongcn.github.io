<!doctype html>
<html lang="en">
  <head>
  <!-- Meta -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex,nofollow" />

  
  
  
  


  
    
    
<link rel="stylesheet" href="/css/github.css">

  

  <meta name="title" content="理解 Service Worker | 风灯零乱 | 独立开发 技术沉淀 思考总结">
  <meta name="keywords" content="Web,独立开发,技术沉淀,思考总结">

  <!-- OpenGraph -->
  <meta name="description" content="Service Worker 是一种 JavaScript Worker，通常用来充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。 它能够劫持从 Web 应用程序发起的请求，并进行灵活的缓存控制，使得在离线环境下也能访问指定的缓存资源，从而提供良好的离线体验。 除了进行细粒度的缓存控制，还可以实现推送通知、后台同步等功能。 前提条件HTTPS 环境由于 Service Worker">
<meta property="og:type" content="article">
<meta property="og:title" content="理解 Service Worker">
<meta property="og:url" content="https://waynegong.cn/posts/23257.html">
<meta property="og:site_name" content="风灯零乱">
<meta property="og:description" content="Service Worker 是一种 JavaScript Worker，通常用来充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。 它能够劫持从 Web 应用程序发起的请求，并进行灵活的缓存控制，使得在离线环境下也能访问指定的缓存资源，从而提供良好的离线体验。 除了进行细粒度的缓存控制，还可以实现推送通知、后台同步等功能。 前提条件HTTPS 环境由于 Service Worker">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://waynegong.cn/images/10/image-1.png">
<meta property="article:published_time" content="2020-10-20T16:00:00.000Z">
<meta property="article:modified_time" content="2022-02-08T03:31:16.430Z">
<meta property="article:author" content="waynegong">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="独立开发">
<meta property="article:tag" content="技术沉淀">
<meta property="article:tag" content="思考总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://waynegong.cn/images/10/image-1.png">

  <!-- Title -->
  <title>理解 Service Worker | 风灯零乱 | 独立开发 技术沉淀 思考总结</title>

  <!-- 收录验证 -->
  <meta name="sogou_site_verification" content="Ya613VDsLE" />
  <meta name="360-site-verification" content="cede68bb0b1448f4d5dcc6cdbdb1239d" />
  <meta name="baidu-site-verification" content="code-CXJVSO2lgq" />

  <!-- GTM -->
  
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-K9CJL9P');</script>
  

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/lib/bootstrap-5.1.3/css/bootstrap.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>

  <body class="container col-lg-8 col-md-10 justify-content-center">
    <header>
  <nav class="navbar sticky-top navbar-light bg-light">
    <div class="container-fluid">
      <a class="navbar-brand" href="/">风灯零乱</a>

      <ul class="nav text-uppercase">
         
        <li class="nav-item">
          <a class="nav-link" href="/archives/"
            >archives</a
          >
        </li>
         
        <li class="nav-item">
          <a class="nav-link" href="/categories/"
            >categories</a
          >
        </li>
         
        <li class="nav-item">
          <a class="nav-link" href="/tags/"
            >tags</a
          >
        </li>
        
      </ul>
    </div>
  </nav>
</header>


    <section class="container-fluid">
  <div class="pb-3 pt-2">
    <h1>
      理解 Service Worker
    </h1>
    <time class="link-secondary fw-light">2020-10-21</time>
  </div>

  <main class="markdown-body">
    <p>Service Worker 是一种 JavaScript Worker，通常用来充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。</p>
<p>它能够劫持从 Web 应用程序发起的请求，并进行灵活的缓存控制，使得在离线环境下也能访问指定的缓存资源，从而提供良好的离线体验。</p>
<p>除了进行细粒度的缓存控制，还可以实现推送通知、后台同步等功能。</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><h3 id="HTTPS-环境"><a href="#HTTPS-环境" class="headerlink" title="HTTPS 环境"></a>HTTPS 环境</h3><p>由于 Service Worker 能直接劫持页面请求，为了避免遭到中间人攻击，只有在 HTTPS 环境下才能进行注册（localhost 除外）。</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>调用 <code>register</code> 注册时，浏览器会根据 Service Worker 文件的路径分配不同的 <code>scope。</code></p>
<p>例如：处于根路径下的 Service Worker 能控制所有的 <code>fetch</code> 请求，处于 <code>/a/b/c/</code> 下的 Service Worker 则只能控制路径以 <code>/a/b/c/</code> 开头页面的 <code>fetch</code> 请求。</p>
<h2 id="Service-Worker-使用"><a href="#Service-Worker-使用" class="headerlink" title="Service Worker 使用"></a>Service Worker 使用</h2><p>Service Worker 的使用主要在于理解生命周期及安装、更新机制。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Service Worker 只需要在页面中进行 <code>register</code> 即可：</p>
<p>例如：<code>navigator.serviceWorker.register(&quot;/sw.js&quot;)</code><br>当用户首次访问页面，将会开始下载并执行 Service Worker 并等待 Service Worker 生命周期事件触发。</p>
<p>Service Worker 加载后第一个触发的是 install 事件。<br>在 install 事件的处理函数中通常会“加载需要离线缓存的资源”并保存在 CacheStorage 中，由于加载网络资源为异步过程，通常还会搭配 event.waitUntill() 一起使用；</p>
<p>在 install 事件的处理函数执行完成后，Service Worker 将会触发 active 事件。<br>但此时 Service Worker 还并不能控制页面发出的请求，页面还是非受控状态。只有当页面刷新后 Service Worker 才能进行实际的控制。</p>
<p>如果希望在首次 install 完成，并触发 active 后立即控制页面，可以使用 self.clents.claim() 立即取得控制权。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>当安装、激活成功后，访问页面时浏览器将会检查文件内容是否有更新，如果文件内容发生改变则触发 Service Worker 更新。</p>
<p>浏览器检查更新时会遵循 Service Worker 文件的 HTTP 缓存设置，但为了防止设置了长时间缓存导致不能被更新到，浏览器在 24 小时内至少会获取一次最新资源。</p>
<p>除了浏览器自身检查更新外，还能通过在页面中 register() 的方式进行更新。</p>
<p>重复调用 register 注册相同的 Service Worker 不会触发更新，但如果 register 的 Service Worker 内容、文件名、参数任意一项发生变化，则也会触发更新；</p>
<p>Service Worker 的更新流程与安装流程稍有差异。</p>
<p>首次安装 Service Worker 时 install 事件执行完成后，会立即触发 active 事件，但当前客户端（页面）处于非受控状态，只有在刷新或新打开的页面中才能取得对新客户端的控制。</p>
<p>更新的 Service Worker 也会立即执行 install 事件，但不会立即触发 active 事件，而是会进入activating 状态等待。直到没有任何页面使用旧的 Service Worker 时，这时才触发 active 事件，并取得后面打开页面的控制权。</p>
<h2 id="Service-Worker-生命周期图"><a href="#Service-Worker-生命周期图" class="headerlink" title="Service Worker 生命周期图"></a>Service Worker 生命周期图</h2><p><img src="/images/10/image-1.png"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>页面强制刷新时，页面获取直接依赖的资源时不会通过 Service Worker；</li>
<li>多个 scop 下安装 service worker 情况</li>
</ul>

  </main>
</sectione>

    
<script src="/lib/bootstrap-5.1.3/js/bootstrap.bundle.min.js"></script>


  </body>
</html>