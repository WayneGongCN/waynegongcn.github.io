<!doctype html>
<html lang="en">
  <head>
      <!-- Meta -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- SEO Meta -->
  
  
  
  

  
    
    
<link rel="stylesheet" href="/lib/hljs/github.css">

  

  <meta name="title" content="Javascript 几种继承方式的差异 | 风灯零乱 | 一个程序员的个人博客">
  <meta name="keywords" content="博客,独立开发,技术沉淀,思考总结,Web 前端">

  <!-- Title -->
  <title>Javascript 几种继承方式的差异 | 风灯零乱 | 一个程序员的个人博客</title>

  <!-- OpenGraph -->
  <meta name="description" content="虽然 ES6 带来了 class 语法使得实现继承非常方便，但是了解 “老” 的继承实现，对理解 Javascript 还是非常有帮助的。 原型链继承实现：父类的实例为子类的原型。 &#x2F;&#x2F; 父类 function SuperType () &amp;#123;   this.property &#x3D; true   this.array &#x3D; [1, 2, 3] &amp;#125; SuperType.prototype">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript 几种继承方式的差异">
<meta property="og:url" content="https://waynegong.cn/posts/42991.html">
<meta property="og:site_name" content="风灯零乱">
<meta property="og:description" content="虽然 ES6 带来了 class 语法使得实现继承非常方便，但是了解 “老” 的继承实现，对理解 Javascript 还是非常有帮助的。 原型链继承实现：父类的实例为子类的原型。 &#x2F;&#x2F; 父类 function SuperType () &amp;#123;   this.property &#x3D; true   this.array &#x3D; [1, 2, 3] &amp;#125; SuperType.prototype">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-28T16:00:00.000Z">
<meta property="article:modified_time" content="2022-02-12T10:03:37.876Z">
<meta property="article:author" content="Wayne Gong">
<meta property="article:tag" content="Javascript">
<meta name="twitter:card" content="summary">

  <!-- 收录验证 -->
  <meta name="sogou_site_verification" content="Ya613VDsLE" />
  <meta name="360-site-verification" content="cede68bb0b1448f4d5dcc6cdbdb1239d" />
  <meta name="baidu-site-verification" content="code-CXJVSO2lgq" />

  <!-- GTM -->
  
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-K9CJL9P');</script>
  

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/lib/bootstrap-5.1.3/css/bootstrap-reboot.min.css">

  
<link rel="stylesheet" href="/lib/bootstrap-5.1.3/css/bootstrap.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  <meta name="generator" content="Hexo 6.0.0"></head>

  <body class="container d-flex flex-column  col-lg-8 col-md-10">
    <header class="container flex-grow-0 line-bottom mb-2 ">
      <nav class="row align-items-center justify-content-between">
  <a class="col navbar-brand text-dark" href="/">风灯零乱</a>

  <ul class="col-auto row p-0 m-0">
    
      
      <li class="col-auto list-style-none">
        <a class="text-dark text-decoration-none" href="/archives/">
          归档
        </a>
      </li>
    
  </ul>
</nav>

    </header>

    <section class="main d-flex flex-column flex-grow-1">
      <section class="container flex-grow-1">
  <div class="pb-3 pt-2">
    <h1>
      Javascript 几种继承方式的差异
    </h1>
    <time class="link-secondary fw-light">2021-03-01</time>
  </div>

  <main class="markdown-body">
    <p>虽然 ES6 带来了 class 语法使得实现继承非常方便，但是了解 “老” 的继承实现，对理解 Javascript 还是非常有帮助的。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>实现：<strong>父类的实例为子类的原型。</strong></p>
<pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>
  <span class="hljs-built_in">this</span>.array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
&#125;
SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.property
&#125;

<span class="hljs-comment">// 子类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.subproperty = <span class="hljs-literal">false</span>
&#125;
SubType.prototype = <span class="hljs-keyword">new</span> SuperType();    <span class="hljs-comment">// 实现原型链继承</span>
SubType.prototype.constructor = SubType;    <span class="hljs-comment">// 修复构造函数指向</span>
SubType.prototype.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subproperty
&#125;

<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> SubType();
<span class="hljs-built_in">console</span>.log(instance.getSuperValue())</code></pre>

<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol>
<li><p>实例化子类时，无法向父类传递参数；</p>
</li>
<li><p>所有子类公用原型（父类实例）中引用类型的值；（当 <code>instance.array</code> 被修改时，会影响到所有的子类实例）；</p>
</li>
</ol>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么基本数据类型的值不会被其他实例修改而影响呢？</p>
<h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>实现：<strong>在子类的构造函数中，通过 <code>call</code> 改变 <code>this</code> 指向为当前实例，执行父类构造函数。</strong></p>
<pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name
    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>]
    <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)
    &#125;
&#125;

<span class="hljs-comment">// 子类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params">name</span>) </span>&#123;
    SuperType.call(<span class="hljs-built_in">this</span>, name)
&#125;

<span class="hljs-keyword">const</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;wayne&#x27;</span>)
<span class="hljs-keyword">const</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;maggie&#x27;</span>)
instance1.sayName()
instance1.colors.push(<span class="hljs-string">&#x27;black&#x27;</span>)

<span class="hljs-built_in">console</span>.log(instance2.colors)   <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;]</span></code></pre>

<p>如此一来，父类上的所有属性都从原型移到了实例自身上，解决了引用类型被共享的问题。</p>
<p>同时，子类在 <code>call</code> 调用时还能向父类构造函数传递参数。</p>
<h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><p>原型链继承的两个缺点分别都被解决了，但同时也引入了另外的缺陷。</p>
<p>在上面的例子中，父类的方法定义在构造函数中，这会导致相同的方法在每一个实例中重复，造成不必要的开销。</p>
<p>但如果像原型链继承一样定义在 <code>prototype</code> 中又不能被子类继承。</p>
<p>为了解决这种问题引入了组合继承。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>实现：<strong>组合继承通过借用构造函数继承父类的属性，通过原型链继承父类的方法。</strong></p>
<pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name
  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>]
&#125;
SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)
&#125;

<span class="hljs-comment">// 子类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params">name, age</span>) </span>&#123;
  SuperType.call(<span class="hljs-built_in">this</span>, name)
  <span class="hljs-built_in">this</span>.age = age
&#125;
SubType.prototype = <span class="hljs-keyword">new</span> SuperType()
SubType.prototype.constructor = SubType
SuperType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)
&#125;

<span class="hljs-keyword">const</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;wayne&#x27;</span>, <span class="hljs-number">18</span>)
instance1.sayName()
instance1.sayAge()
instance1.colors.push(<span class="hljs-string">&#x27;black&#x27;</span>)
<span class="hljs-built_in">console</span>.log(instance1.colors)

<span class="hljs-keyword">const</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;maggie&#x27;</span>, <span class="hljs-number">18</span>)
instance2.sayName()
instance2.sayAge()
<span class="hljs-built_in">console</span>.log(instance2.colors)

<span class="hljs-built_in">console</span>.log(instance1.sayAge === instance2.sayAge)</code></pre>

<p>组合继承通过结合原型链继承和借用构造函数继承双方的优点成为了 JavaScript 中最常用的继承模式。</p>
<h3 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h3><p>虽然组合继承模式已经集成了上面两种模式的优点，但依然还存在有缺陷。</p>
<p>仔细观察上面的代码可以发现，由于<strong>调用了两次父类的构造函数</strong>，导致在子类的实例和原型上存在<strong>重复的属性</strong>。只是由于原型链从下至上的访问顺序导致原型上的重复属性被屏蔽了。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>使用构造函数能够创建自定义类，但有时我们需要的仅仅是一个继承了某些特定属性、方法的对象，而不需要一个类。对于这种情况可以使用原型式继承来完成。</p>
<p>原型式继承的实现方式有多种，主要思路是以基类为基础，通过某种方式<strong>复制基类</strong>来完成：</p>
<p>原型式继承和原型链继承一样，也会遇到引用类型值被共享的问题。</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person= &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wayne&#x27;</span>,
  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;maggie&#x27;</span>, <span class="hljs-string">&#x27;some girls&#x27;</span>]
&#125;

<span class="hljs-comment">// 通过 Object.create 实现</span>
<span class="hljs-keyword">const</span> anotherPerson = <span class="hljs-built_in">Object</span>.create(person)
anotherPerson.name = <span class="hljs-string">&#x27;maggie&#x27;</span>
anotherPerson.friends.push(<span class="hljs-string">&#x27;some boys&#x27;</span>)

<span class="hljs-comment">// 通过 Object() 实现</span>
<span class="hljs-keyword">const</span> yetAnotherPerson = <span class="hljs-built_in">Object</span>(person)
yetAnotherPerson.name = <span class="hljs-string">&#x27;jack&#x27;</span>
yetAnotherPerson.friends.push(<span class="hljs-string">&#x27;cat&#x27;</span>)

<span class="hljs-comment">// ...</span></code></pre>

<h2 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h2><p>原型继承的核心是复制要继承的基类，但通常我们还需要对基类进行一系列修改或增强。寄生继承借鉴了工厂模式，<strong>将复制基类与增强的过程进行封装</strong>。</p>
<p>虽然增加的逻辑能被复用，但被增强的方法本身却不能复用，存在额外的开销：</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span> (<span class="hljs-params">original</span>) </span>&#123;
  <span class="hljs-keyword">const</span> clone = <span class="hljs-built_in">Object</span>(original);
  clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);
  &#125;
  <span class="hljs-keyword">return</span> clone
&#125;</code></pre>

<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>原型继承、寄生继承缺点明显，很少单独使用。组合继承存在的问题也依然没有解决。</p>
<p>有没有更好的继承模式呢？</p>
<p>回忆一下组合继承存在的问题：<strong>多次调用构造函数</strong>、<strong>实例属性与原型属性重复</strong>。</p>
<p>等等…构造函数多次调用？<br>在原型继承与寄生继承中都是使用没有构造函数，能不能将寄生继承与组合继承结合起来取长补短呢？</p>
<p>答案就是寄生组合模式。</p>
<p>寄生组合模式就是通过借用构造函数来继承属性，通过原型链的混合形式来继承方法。在指定子类原型时不一定要通过实例化父类来实现，子类需要的无非就是父类原型上的方法，复制一份即可。</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritancePrototype</span> (<span class="hljs-params">superType, subType</span>) </span>&#123;
  <span class="hljs-keyword">const</span> prototype = <span class="hljs-built_in">Object</span>(superType.prototype)
  subType.prototype = prototype
  subType.prototype.constructor = subType
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name
&#125;
SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params">name, age</span>) </span>&#123;
  SuperType.call(<span class="hljs-built_in">this</span>, name)
  <span class="hljs-built_in">this</span>.age = age
&#125;
inheritancePrototype(SuperType, SubType)
SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)
&#125;</code></pre>

<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>为什么需要有 <code>const prototype = Object(superType.prototype) </code>，直接 <code>subType.prototype = superType.prototype</code> 会出现什么问题？</p>

  </main>
</sectione>
    </section>

    <footer class="container flex-grow-0 line-top mt-4 p-1 pb-2">
      <ul class="row align-items-center m-0 p-0 em-6 text-muted " >
  
  <li class="list-style-none p-0">© 2022 <a href="mailto:wayne.gong.cn@hotmail.com" class="text-reset">Wayne Gong</a> All Rights Reserved</li>

  <li class="list-style-none p-0">Powered by <a href="https://hexo.io/" class="text-reset" target="_blank" rel="noopener">Hexo</a></li>
  <li class="list-style-none p-0">Theme by <a href="https://github.com/WayneGongCN/hexo-theme-atheme" class="text-reset" target="_blank" rel="noopener">atheme</a></li>

  
    
    <li class="list-style-none p-0"><a href="https://github.com/waynegongcn/waynegongcn.github.io/edit/master/source/_posts/Javascript 几种继承方式的差异.md" class="text-reset" target="_blank" rel="noopener">Edit Page</a></li>
  
</ul>


    </footer>

    <!-- 
<script src="/lib/bootstrap-5.1.3/js/bootstrap.bundle.min.js"></script>
 -->
  </body>
</html>